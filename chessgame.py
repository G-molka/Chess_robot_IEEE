# -*- coding: utf-8 -*-
"""chessgame.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rS77WQQXykjXCADK7moqSM7fODIw2qvo
"""

!pip install python-chess
!pip install opencv-python
!pip install picamera
!pip install stockfish
from stockfish import Stockfish
import tkinter as tk
from tkinter import messagebox
import chess
import chess.engine
from PIL import Image, ImageTk
import numpy as np
import tensorflow as tf
import cv2
import picamera

"""Camera initialization"""

camera = picamera.PICamera()
camera.resolution = (640, 480)
camera.framerate = 30

"""piece detection model importation"""

model = tf.keras.models.load_model('chess_pieces')

"""Chess engine"""

stockfish = Stockfish(path="/usr/games/stockfish")

"""Chessboard GUI"""

root = tk.Tk()
root.title("Chess Coach Robot")

board = chess.Board()

selected_square = None

turn_label = tk.Label(root, text="Your turn!", font=("Arial", 14))
turn_label.grid(row=0, column=0, columnspan=2)

feedback_label = tk.Label(root, text="Feedback will appear here", font=("Arial", 12))
feedback_label.grid(row=1, column=0, columnspan=2)


# Function to update the board image
def update_board_image():
    board_image = np.zeros((8, 8), dtype=int)  # Empty chessboard
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            board_image[square // 8, square % 8] = piece.piece_type
    img = create_chessboard_image(board_image)
    chessboard_image = ImageTk.PhotoImage(img)
    board_label.config(image=chessboard_image)
    board_label.image = chessboard_image

# Create chessboard image from pieces
def create_chessboard_image(board_image):
    img = Image.new("RGB", (400, 400), color=(255, 255, 255))  # White background
    tile_size = 50
    for row in range(8):
        for col in range(8):
            color = (255, 255, 255) if (row + col) % 2 == 0 else (0, 0, 0)  # Alternate tiles
            img.paste(Image.new("RGB", (tile_size, tile_size), color=color), (col * tile_size, row * tile_size))
            piece = board_image[row, col]
            if piece != 0:
                piece_image = get_piece_image(piece)
                img.paste(piece_image, (col * tile_size, row * tile_size), piece_image)
    return img

# Map piece types to images
def get_piece_image(piece):
    piece_dict = {
        1: "pawnw.png",
        2: "knightw.png",
        3: "bishopw.png",
        4: "rookw.png",
        5: "queenw.png",
        6: "kingw.png",
        7: "pawnb.png",
        8: "knightb.png",
        9: "bishopb.png",
        10: "rookb.png",
        11: "queenb.png",
        12: "kingb.png"
    }
    piece_image = Image.open(piece_dict[piece])
    piece_image = piece_image.resize((50, 50))
    return piece_image

def process_frame():
    frame = np.empty((480, 640, 3), dtype=np.uint8)  # Create an empty frame array
    camera.capture(frame, 'rgb')  # Capture the frame in RGB format

    # Resize the captured frame to fit the model's expected input size
    resized_frame = cv2.resize(frame, (224, 224))  # Adjust to your model's input size

    # Preprocess the frame for TensorFlow model
    input_tensor = tf.convert_to_tensor(resized_frame, dtype=tf.float32)
    input_tensor = tf.image.convert_image_dtype(input_tensor, dtype=tf.uint8)
    input_tensor = input_tensor[tf.newaxis, ...]  # Add batch dimension

    # Get predictions from the model
    predictions = model.predict(input_tensor)

    return predictions

def extract_piece_positions(predictions):
    piece_positions = {}

    piece_labels = ['empty', 'w_pawn', 'w_knight', 'w_bishop', 'w_rook', 'w_queen', 'w_king',
                    'b_pawn', 'b_knight', 'b_bishop', 'b_rook', 'b_queen', 'b_king']

    for i, prediction in enumerate(predictions[0]):
        predicted_class = np.argmax(prediction)
        piece = piece_labels[predicted_class]
        if piece != 'empty':
            square = chess.square(i % 8, i // 8)
            piece_positions[square] = piece

    return piece_positions

def update_board_state(piece_positions):
    board = chess.Board()
    for position, piece in piece_positions.items():
        piece_type = piece.split('_')[1]
        piece_code = get_piece_code(piece_type)
        board.set_piece_at(position, chess.Piece(piece_code, piece[0] == 'w'))
    return board

def get_piece_code(piece_type):
    piece_dict = {
        'pawn': chess.PAWN,
        'knight': chess.KNIGHT,
        'bishop': chess.BISHOP,
        'rook': chess.ROOK,
        'queen': chess.QUEEN,
        'king': chess.KING
    }
    return piece_dict.get(piece_type, chess.PAWN)

def update_board_state(piece_positions):
    board = chess.Board()
    for position, piece in piece_positions.items():
        board.set_piece_at(position, piece)
    return board

"""Human Move"""

def on_square_click(event, row, col):
    global selected_square
    if selected_square is None:
        selected_square = (row, col)
        return

    move_from = chess.square(selected_square[1], selected_square[0])
    move_to = chess.square(col, row)

    move = chess.Move(move_from, move_to)
    if move in board.legal_moves:
        board.push(move)
        update_board_image()

        if board.is_game_over():
            show_game_result()
            return
        robot_move = get_robot_move(board)
        board.push(robot_move)
        update_board_image()
        move_feedback = evaluate_move(move, robot_move)
        feedback_label.config(text=move_feedback)
        if board.is_game_over():
            show_game_result()
    else:
        messagebox.showerror("Invalid Move", "The move you selected is not legal!")

    selected_square = None

"""Feedback on the Human's Move"""

def evaluate_move(player_move, robot_move):
    if player_move == str(robot_move):
        return "Good move! Keep it up!"
    else:
        return f"Try better! Stockfish suggests: {robot_move}"

"""Robot's Move"""

def get_robot_move(board):
    result = engine.play(board, chess.engine.Limit(time=2.0))
    return result.move

""" Display Game Results"""

def show_game_result():
    if board.is_checkmate():
        result = "Checkmate! You lost."
    elif board.is_stalemate():
        result = "Stalemate! It's a draw."
    elif board.is_insufficient_material():
        result = "Insufficient material for checkmate. It's a draw."
    else:
        result = "Game Over"
    messagebox.showinfo("Game Over", result)

"""Play a game"""

def play_game():
    board = chess.Board()

    turn_label.config(text="Your turn!")

    while True:
        predictions = process_frame()
        piece_positions = extract_piece_positions(predictions)

        board = update_board_state(piece_positions)

        update_board_image()
        turn_label.config(text="Your turn!")

        root.wait_variable(selected_square)

        if selected_square is not None:
            move_from = chess.square(selected_square[1], selected_square[0])
            move_to = chess.square(selected_square[3], selected_square[2])

            move = chess.Move(move_from, move_to)

            if move in board.legal_moves:
                board.push(move)
                update_board_image()

                feedback_label.config(text="Good move!")

                robot_move = get_robot_move(board)
                print(f"Robot's move: {robot_move}")
                board.push(robot_move)
                update_board_image()

                feedback_label.config(text=f"Robot's move: {robot_move}")


                if board.is_game_over():
                    print("Game Over")
                    show_game_result()
                    break

                turn_label.config(text="Your turn!")

play_game()
engine.quit()