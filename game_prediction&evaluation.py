# -*- coding: utf-8 -*-
"""game prediction&evaluation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TyqUxTbY98GqZ9SYrrsqZkoUHrr-pixj
"""

!pip install python-chess
import numpy as np
import pandas as pd
import chess
import chess.engine
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, mean_squared_error
import tensorflow as tf

dataset = pd.read_csv("chess_game_data.csv")

print(dataset.head())

def board_to_vector(board_state):
    board_vector = np.zeros(64)
    moves = board_state.split('')
    board = chess.Board()

    for move in moves:
        if chess.Move.from_uci(move) in board.legal_moves:
            board.push(chess.Move.from_uci(move))

    for i in range(64):
        piece = board.piece_at(i)
        if piece is not None:
            piece_type = piece.piece_type
            color = piece.color
            board_vector[i] = piece_type + (6 if color == chess.WHITE else 0)
    return board_vector

"""Classification Model"""

X = np.array([board_to_vector(board) for board in dataset['board_state']])
y_outcome = pd.Categorical(dataset['outcome']).codes

X_train, X_test, y_train_outcome, y_test_outcome = train_test_split(X, y_outcome, test_size=0.2, random_state=42)

classification_model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(64,)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(3, activation='softmax')
])

classification_model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

classification_model.fit(X_train, y_train_outcome, epochs=10, batch_size=32)

y_pred_outcome = np.argmax(classification_model.predict(X_test), axis=1)
classification_accuracy = accuracy_score(y_test_outcome, y_pred_outcome)
print(f"Classification Accuracy (Win/Loss/Draw prediction): {classification_accuracy}")

"""Regression Model"""

X = np.array([d["board_state"] for d in data])
y_move_quality = np.array([d["human_move_quality"] for d in data])

X_train, X_test, y_train_move, y_test_move = train_test_split(X, y_move_quality, test_size=0.2, random_state=42)

regression_model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(64,)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1)
])

regression_model.compile(optimizer='adam', loss='mean_squared_error')

regression_model.fit(X_train, y_train_move, epochs=10, batch_size=32)

y_pred_move_quality = regression_model.predict(X_test)
move_quality_error = mean_squared_error(y_test_move, y_pred_move_quality)
print(f"Mean Squared Error for Move Quality Prediction: {move_quality_error}")

"""model result"""

board_vector = board_to_vector(chess.Board())
move_quality_prediction = regression_model.predict(np.array([board_vector]))
print("Predicted Move Quality:", move_quality_prediction[0])